# Introduction to phylogenetics {#phylogenetics}

Most of the topics in this book are just introduced, and when you start using the tools you will
have to study the original literature. This is true to a probably greater extent for phylogenetics
which is a truly vast area of computational methodology. It is also one which has for long been
fraught by strongly held opinions bordering on methodological wars. In this chapter I will try to
give an overview of available tools and methods, together with some advice on how to address typical
situations and problems. I will try to be neutral, but at times my own opinions might shine through,
since I actually want to convey some personal expericences of mine in the hope they might be useful
to you.

## \index{multiple sequence alignment}Multiple sequence \index{alignment}alignments, homology and trees {#multiple-sequence-alignment}

Today, the most common starting point to estimate a phylogenetic tree are nucleotide or protein
sequences. Moreover, the sequences are aligned so that corresponding positions are placed at the
same relative positions. The idea behind aligning sequences like this is that we can capture
nucleotides or amino acids that are \index{homology}*homologous*, i.e. are derived from the same
nucleotide or amino acid state in a common ancestral sequence. This is similar to the alignments
that were discussed in the chapter about annotation (chapter \@ref(annotation)), but whereas they
were *pairwise*, the alignments you use for estimating trees are *multiple*, i.e. contain more than
two sequences.

An alignment of a few rather similar protein sequences can look like this (in *phylip* format):

```
9   49
S._cerevisiae_NrdAe             GLIPMIRVFN NTARYVDQGG NKRPGAFALF LEPWHADIFD FVDIRKTHG
E._coli_KTE27_NrdAg             GCIPFYKHFQ TAVKSCSQGG -VRGGAATLF YPMWHLEVES LLVLKNNRG
Clostridium_acetobutylicum_ATC  GVVPWVKLFN DTAIAVDQLG -VRNGSVAVW LDAWHKDLPE FMQLRTNNG
T._denticola_NrdAh              GIIRWIKLAN DTAVAVDQLG -VRQGSVAVY LDVWHKDIPE FLQLRTNNG
A._baumannii_NrdAi              GAREVIDDFF TAASKISQGG -NRRGSFAAY LDIEHDDFYE CLDSLRTHS
Streptomyces_sp._NrdAn          GIVPFLKTLD ASVAAVNQGG -RRKGAAAVY LETWHADIEE FLELRDNTG
Delftia_sp._NrdAz               GVVPFLKVVN DTAVAVNQGG -KRKGAVCTY LETWHLDIEE FLELRKNTG
S._aureus_NrdE                  GVLPIAKSLE GGFSYADQLG -QRPGAGAVY LNIFHYDVEE FLDTKKVNA
B._subtilis_NrdE                GVVGVMKLLD NAFRYADQMG -QRQGSGAVY LSVFHPDITD FLDTKKISA
```

It is often better to look at sequence alignments in specialized programs, e.g.
[Seaview](http://doua.prabi.fr/software/seaview) [@gouy_seaview_2010],
[ClustalX](http://www.clustal.org/) [@thompson_multiple_2003] or [JalView](http://www.jalview.org/)
[@clamp_jalview_2004] (avoid the alignment program, ClustalW, in ClustalX; there are better
alternatives today).

![*View of a multiple sequence alignment in Seaview*. Programs that display and lets you work with
multiple sequence alignments colours amino acids so it's easier to see *conservative substitutions*,
i.e. substitutions between biochemically similar amino acids.](img/seaview_screenshot.png)

When you run a phylogenetic tree building software it will consider each column as a separate
character with different *states* in each sequence. This information will then be used to estimate
the phylogeny.

## Different types of tree building algorithms

There are essentially three types of algorithms used to estimate a phylogeny from a set of aligned
sequences:

1. Distance-based

   Distance-based methods calculate a pairwise distance between all sequences in the alignment, and
   then uses the distances to group sequences separated by short distances nearby each other in the
   tree. The most widely used algorithm in this class is \index{neighbor joining}*neighbor joining*
   -- affectionately known as *NJ* -- which is a fast \index{heuristic algorithm}*heuristic*,
   \index{greedy algorithm}*greedy* algorithm (see appendix \@ref(computer-terms), Computer terms)
   [@saitou_neighbor-joining_1987].  There are also non-greedy algorithms that aims to find the
   shortest tree, i.e. the tree with the shortest possible sum of branch lengths where branch
   lengths are proportional to distances. An example of a non-greedy algorithm is FastME (ME is
   short for *Minimum Evolution*) [@lefort_fastme_2015].

2. Parsimony

   \index{parsimony}*Parsimony* in phylogenetics builds on the famous philosophical principle known
   as *Occam's razor* which contends that "simpler solutions are more likely to be correct than
   complex ones" ([quote from Wikipedia](https://en.wikipedia.org/wiki/Occam%27s_razor)). This is
   interpreted in phylogenetics as "find the tree that minimizes the number of changes of state".
   States were, before sequences were available, morphological character states. A tree of
   vertebrates would hence suggest three origins of powered flight (birds, bats and pterosaurs) --
   three transitions of state in the forelimbs from legs to wings --
   considering presence or absence of wings, birth of live offspring, the shape of the pelvis and a
   few other characters. In sequence based parsimony, state transitions are transitions between the
   different nucleotides or amino acids. 

3. Probabilistic
   
   NNN

### Exploring tree space

The parsimony and probabilistic phylogenetic algorithms look for the optimal tree, which requires
that all possible trees are checked. Since this is a very large number for any reasonable number of
sequences (there are, e.g., $10^{76}$ possible rooted trees with 50 species/sequences), any
algorithm will hence have to be \index{heuristic algorithm}heuristic. They are, as far as I know,
never *greedy* like the most common distance based methods. Instead, parsimony algorithms rely on
different ways of *exploring tree space* and calculating parsimony scores on each. If you're
interested in how this is done, I can suggest e.g. Joseph Felsenstein's seminal book *Inferring
phylogenies* @felsenstein_inferring_2004.

```{r include=FALSE}
# vim:tw=100
```
